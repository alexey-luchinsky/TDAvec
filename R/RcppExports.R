# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' computeECC
#' @param D N by 3 matrix (columns contain dimension, birth and death values respectively)
#' @param maxhomDim maximum homological dimension considered (0 for H0, 1 for H1, etc.)
#' @param scaleSeq sequence of scale values for vectorization
#' @examples
#' N <- 100
#' set.seed(123)
#' X <- TDA::circleUnif(N) + rnorm(2*N,mean = 0,sd = 0.2)
#' D <- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 
#' scaleSeq = seq(0,2,length.out=11)
#' computeECC(D,maxhomDim = 1,scaleSeq)
computeECC <- function(D, maxhomDim, scaleSeq) {
    .Call(`_TDAvec_computeECC`, D, maxhomDim, scaleSeq)
}

#' computePES
#' @param D N by 3 matrix (columns contain dimension, birth and death values respectively)
#' @param homDim homological dimension (0 for H0, 1 for H1, etc.)
#' @param scaleSeq sequence of scale values for vectorization
#' @examples
#' N <- 100
#' set.seed(123)
#' X <- TDA::circleUnif(N) + rnorm(2*N,mean = 0,sd = 0.2)  
#' D <- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram  # compute PD using Rips filtration
#' scaleSeq = seq(0,2,length.out=11) # sequence of scale values
#' computePES(D,homDim = 0,scaleSeq) # compute PES for homological dimension H0
#' computePES(D,homDim = 1,scaleSeq) # compute PES for homological dimension H1
computePES <- function(D, homDim, scaleSeq) {
    .Call(`_TDAvec_computePES`, D, homDim, scaleSeq)
}

#' Calculates the Persistence Image
#' 
#' @param D N by 3 matrix (columns contain dimension, birth and persistence values respectively)
#' @param homDim homological dimension (0 for H0, 1 for H1, etc.)
#' @param xSeq sequence of x (birth) values of the grid vertices
#' @param ySeq sequence of y (persistence) values of the grid vertices
#' @param res resolution parameter
#' @param sigma sigma parameter
#' @examples
#' N <- 100
#' set.seed(123)
#' X <- TDA::circleUnif(N) + rnorm(2*N,mean = 0,sd = 0.2)  
#' D <- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 
#' D[,3] <- D[,3] - D[,2] 
#' colnames(D)[3] <- "Persistence"
#' res <- 5 # resolution or grid size
#'   
#' minPH0 <- min(D[D[,1]==0,3]); maxPH0 <- max(D[D[,1]==0,3])
#' sigma <- 0.5*(maxPH0-minPH0)/res
#' computePI(D,homDim=0,res,sigma,minB=NA,maxB=NA,minPH0,maxPH0)
#'     
#' minBH1 <- min(D[D[,1]==1,2]); maxBH1 <- max(D[D[,1]==1,2])
#' minPH1 <- min(D[D[,1]==1,3]); maxPH1 <- max(D[D[,1]==1,3])
#' sigma <- 0.5*(maxPH1-minPH1)/res # default way of selecting sigma - can be overridden 
#' computePI(D,homDim=1,res,sigma,minBH1,maxBH1,minPH1,maxPH1)
computePI <- function(D, homDim, res, sigma, minB, maxB, minP, maxP) {
    .Call(`_TDAvec_computePI`, D, homDim, res, sigma, minB, maxB, minP, maxP)
}

#' A Vector Summary of the Persistence Landscape Function
#' 
#' @param D N by 3 matrix (columns contain dimension, birth and death values respectively)
#' @param homDim homological dimension (0 for H0, 1 for H1, etc.)
#' @param scaleSeq sequence of scale values for vectorization
#' @param k order of landscape function
#' @examples
#' N <- 100
#' set.seed(123)
#' X <- TDA::circleUnif(N) + rnorm(2*N,mean = 0,sd = 0.2)
#' D <- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 
#' scaleSeq = seq(0,2,length.out=11) # sequence of scale values
#' computePL(D,homDim=0,k=1,scaleSeq)
#' computePL(D,homDim=1,k=1,scaleSeq)
computePL <- function(D, homDim,scaleSeq,k=1) {
    .Call(`_TDAvec_computePL`, D, homDim, scaleSeq,k)
}

#' Calculates the Persistence Silhouettes
#' 
#' @param D N by 3 matrix (columns contain dimension, birth and death values respectively)
#' @param homDim homological dimension (0 for H0, 1 for H1, etc.)
#' @param scaleSeq sequence of scale values for vectorization
#' @param p power of the weights for the silhouette function
#' @examples
#' N <- 100
#' set.seed(123)
#' X <- TDA::circleUnif(N) + rnorm(2*N,mean = 0,sd = 0.2)
#' D <- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 
#' scaleSeq = seq(0,2,length.out=11) # sequence of scale values
#' computePS(D,homDim=0,p=1,scaleSeq)
computePS <- function(D, homDim, scaleSeq,p=1) {
    .Call(`_TDAvec_computePS`, D, homDim, scaleSeq,p)
}

#' Vector of Averaged Bettis
#' 
#' @param D N by 3 matrix (columns contain dimension, birth and death values respectively)
#' @param homDim homological dimension (0 for H0, 1 for H1, etc.)
#' @param scaleSeq sequence of scale values for vectorization
#' @examples
#' N <- 100
#' set.seed(123)
#' X <- TDA::circleUnif(N) + rnorm(2*N,mean = 0,sd = 0.2)
#' D <- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram
#' scaleSeq = seq(0,2,length.out=11)
#' computeVAB(D,homDim = 0,scaleSeq)
#' computeVAB(D,homDim = 1,scaleSeq)
computeVAB <- function(D, homDim, scaleSeq) {
    .Call(`_TDAvec_computeVAB`, D, homDim, scaleSeq)
}

#' Calculates the Vector Persistence Block
#' 
#' @param D N by 3 matrix (columns contain dimension, birth and persistence values respectively)
#' @param homDim homological dimension (0 for H0, 1 for H1, etc.)
#' @param xSeq sequence of x (birth) values of the grid vertices
#' @param ySeq sequence of y (persistence) values of the grid vertices
#' @param tau parameter (between 0 and 1) controlling block width. weight function w(x,y) = x+y
#' @examples
#' X <- TDAstats::circle2d + rnorm(200,mean = 0,sd = 0.1)
#' D <- TDAstats::calculate_homology(X,dim = 1,threshold = 2)
#' D[,3] <- D[,3] - D[,2]
#' xSeq <- unique(quantile(D[D[,1]==1,2],probs = seq(0,1,by=0.1)))
#' ySeq <- unique(quantile(D[D[,1]==1,3],probs = seq(0,1,by=0.1)))
#' computeVPB(D,homDim = 0, xSeq=xSeq, ySeq,tau = 0.5)
computeVPB <- function(D, homDim, xSeq, ySeq, tau) {
    .Call(`_TDAvec_computeVPB`, D, homDim, xSeq, ySeq, tau)
}

