# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculates the Persistence Image
#' 
#' @param D N by 3 matrix (columns contain dimension, birth and persistence values respectively)
#' @param homDim homological dimension (0 for H0, 1 for H1, etc.)
#' @param res resolution parameter
#' @param sigma sigma parameter
#' @param minB minimal birth value
#' @param maxB maximal birth value
#' @param minP minimal persistance value
#' @param maxP maxzimal persistance value
#' @examples
#' N <- 100
#' set.seed(123)
#' X <- TDA::circleUnif(N) + rnorm(2*N,mean = 0,sd = 0.2)  
#' D <- TDA::ripsDiag(X,maxdimension = 1,maxscale = 2)$diagram 
#' D[,3] <- D[,3] - D[,2] 
#' colnames(D)[3] <- "Persistence"
#' res <- 5 # resolution or grid size
#'   
#' minPH0 <- min(D[D[,1]==0,3]); maxPH0 <- max(D[D[,1]==0,3])
#' sigma <- 0.5*(maxPH0-minPH0)/res
#' computePI(D,homDim=0,res,sigma,minB=NA,maxB=NA,minPH0,maxPH0)
#'     
#' minBH1 <- min(D[D[,1]==1,2]); maxBH1 <- max(D[D[,1]==1,2])
#' minPH1 <- min(D[D[,1]==1,3]); maxPH1 <- max(D[D[,1]==1,3])
#' sigma <- 0.5*(maxPH1-minPH1)/res # default way of selecting sigma - can be overridden 
#' computePI(D,homDim=1,res,sigma,minBH1,maxBH1,minPH1,maxPH1)
computePI <- function(D, homDim, res, sigma, minB, maxB, minP, maxP) {
    .Call(`_TDAvec_computePI`, D, homDim, res, sigma, minB, maxB, minP, maxP)
}

computePL <- function(D, homDim, k, scaleSeq) {
    .Call(`_TDAvec_computePL`, D, homDim, k, scaleSeq)
}

computePS <- function(D, homDim, p, scaleSeq) {
    .Call(`_TDAvec_computePS`, D, homDim, p, scaleSeq)
}

computeSWdist <- function(d1, d2, homDim, M = 10L) {
    .Call(`_TDAvec_computeSWdist`, d1, d2, homDim, M)
}

computeVAB <- function(D, homDim, scaleSeq) {
    .Call(`_TDAvec_computeVAB`, D, homDim, scaleSeq)
}

#' @export
computeVPB <- function(D, homDim, xSeq, ySeq, tau) {
    .Call(`_TDAvec_computeVPB`, D, homDim, xSeq, ySeq, tau)
}

rcpp_hello <- function() {
    .Call(`_TDAvec_rcpp_hello`)
}

